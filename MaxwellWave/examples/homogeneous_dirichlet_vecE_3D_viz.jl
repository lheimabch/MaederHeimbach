using Documenter
using Printf
using GLMakie
using LinearAlgebra

include("../src/auxiliary.jl")

@doc raw"""
    vizme()

Generates a 3D gif from the data generated by homogeneous_dirichlet_vecE_3D.jl.
The settings in the function have to by changed to match homogeneous_dirichlet_vecE_3D.jl for a functioning script.
"""
@views function vizme()
    # numerical parameters
    nt = 1000
    nvis = 10

    #get from mulitxpu run
    dims = [2,1,1]

    #grid and plot parameters
    lx = 10
    ly = lx
    lz = lx
    nx = 40
    ny = nx
    nz = nx
    nx_v,ny_v,nz_v = (nx-2)*dims[1],(ny-2)*dims[2],(nz-2)*dims[3]
    
    sparse = [4,2,2] # ceil.(Int64,[nx_v,ny_v,nz_v]./15)
    u  = zeros(Float32,3,nx_v,ny_v,nz_v)
    xc      = LinRange(0, lx, nx_v)
    yc      = LinRange(0, ly, ny_v)
    zc      = LinRange(0, lz, nz_v)
    dx      = lx/(nx_v-1)
    dy      = ly/(ny_v-1)
    dz      = lz/(nz_v-1)
    fig     = Figure(resolution=(1600,1000),fontsize=24,backgroundcolor = "gray")
    ax       = Axis3(fig[1,1];aspect=(1,1,0.5),title="Electric Field",xlabel="lx",ylabel="ly",zlabel="lz")
    load_array("homogeneous_dirichlet_vecE_3D/out_T_00001",u)

    
    ps = [Point3f(x, y, z) for x in xc[1:sparse[1]:end] for y in yc[1:sparse[2]:end] for z in zc[1:sparse[3]:end]]
    ns = map(p -> Vec3f(u[1,Int(round(p[1]/dx+1)),Int(round(p[2]/dy+1)),Int(round(p[3]/dz+1))], u[2,Int(round(p[1]/dx+1)),Int(round(p[2]/dy+1)),Int(round(p[3]/dz+1))], u[3,Int(round(p[1]/dx+1)),Int(round(p[2]/dy+1)),Int(round(p[3]/dz+1))]), ps)
    lengths = norm.(ns)
    plt = arrows!(
        ps, ns, fxaa=true, # turn on anti-aliasing
        color=lengths,
        normalize = false,
        colormap = :turbo,  
        arrowsize = Vec3f(0.1, 0.1, 0.02),
        linewidth = 0.08
    )

    record(fig, "docs/homogeneous_dirichlet_vecE_3D.gif", 2:nt/nvis; framerate = 4) do iframe
        empty!(fig)

        load_array(@sprintf("homogeneous_dirichlet_vecE_3D/out_T_%05d",iframe),u)
        ax       = Axis3(fig[1,1];aspect=(1,1,0.5),title="Electric Field",xlabel="lx",ylabel="ly",zlabel="lz")
        ps = [Point3f(x, y, z) for x in xc[1:sparse[1]:end] for y in yc[1:sparse[2]:end] for z in zc[1:sparse[3]:end]]
        ns = map(p -> Vec3f(u[1,Int(round(p[1]/dx+1)),Int(round(p[2]/dy+1)),Int(round(p[3]/dz+1))], u[2,Int(round(p[1]/dx+1)),Int(round(p[2]/dy+1)),Int(round(p[3]/dz+1))], u[3,Int(round(p[1]/dx+1)),Int(round(p[2]/dy+1)),Int(round(p[3]/dz+1))]), ps)
        lengths = norm.(ns)
        plt = arrows!(
            ps, ns, fxaa=true, # turn on anti-aliasing
            color=lengths,
            normalize = false,
            colormap = :turbo,  
            arrowsize = Vec3f(0.1, 0.1, 0.02),
            linewidth = 0.08
        )
    end
    return nothing
end


vizme()